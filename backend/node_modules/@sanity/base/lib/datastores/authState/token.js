"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveToken = exports.getToken = exports.fetchToken = exports.clearToken = exports.authToken$ = void 0;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _config = require("./config");

var _state = require("./state");

var storage = _interopRequireWildcard(require("./storage"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Project ID is part of the localStorage key so that different projects can store their separate tokens, and it's easier to do book keeping.
var getStorageKey = projectId => {
  if (!projectId) {
    throw new Error('Invalid project id');
  }

  return "__studio_auth_token_".concat(projectId);
};

var saveToken = _ref => {
  var token = _ref.token,
      projectId = _ref.projectId;

  try {
    storage.set(getStorageKey(projectId), JSON.stringify({
      token,
      time: new Date().toISOString()
    }));
  } catch (err) {
    console.error(err);
  }
};

exports.saveToken = saveToken;

var clearToken = projectId => {
  try {
    storage.del(getStorageKey(projectId));
  } catch (err) {
    console.error(err);
  }
};

exports.clearToken = clearToken;

var getToken = projectId => {
  try {
    var item = storage.get(getStorageKey(projectId));

    if (item) {
      var _JSON$parse = JSON.parse(item),
          token = _JSON$parse.token;

      if (token && typeof token === 'string') {
        return token;
      }
    }
  } catch (err) {
    console.error(err);
  }

  return null;
};

exports.getToken = getToken;

var fetchToken = (sid, client) => {
  return client.observable.request({
    method: 'GET',
    uri: "/auth/fetch",
    query: {
      sid
    },
    tag: 'auth.fetch-token'
  });
}; // TODO: some kind of refresh mechanism here when we support refresh tokens / stamping?


exports.fetchToken = fetchToken;
var freshToken$ = (0, _rxjs.defer)(() => {
  if (typeof window === 'undefined' || !(0, _config.authTokenIsAllowed)()) {
    return _rxjs.EMPTY;
  }

  var _readConfig = (0, _config.readConfig)(),
      projectId = _readConfig.projectId;

  if (!projectId) {
    throw new Error('No projectId configured');
  }

  return (0, _rxjs.of)(getToken(projectId));
});
var authToken$ = (0, _rxjs.defer)(() => (0, _rxjs.concat)(freshToken$, (0, _rxjs.merge)(_state.authStateChangedInOtherWindow$, _state.authStateChangedInThisWindow$).pipe((0, _operators.switchMapTo)(freshToken$)))).pipe((0, _operators.shareReplay)({
  bufferSize: 1,
  refCount: true
}));
exports.authToken$ = authToken$;