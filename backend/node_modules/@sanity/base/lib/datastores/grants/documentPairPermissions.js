"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unstable_getDocumentPairPermissions = getDocumentPairPermissions;
exports.unstable_useDocumentPairPermissions = void 0;

var _draftUtils = require("part:@sanity/base/util/draft-utils");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _createHookFromObservableFactory = require("../../util/createHookFromObservableFactory");

var _snapshotPair = require("../document/document-pair/snapshotPair");

var _grantsStore = _interopRequireDefault(require("./grantsStore"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var checkDocumentPermission = _grantsStore.default.checkDocumentPermission;

function getSchemaType(typeName) {
  var schemaMod = require('part:@sanity/base/schema');

  var schema = schemaMod.default || schemaMod;
  var type = schema.get(typeName);

  if (!type) {
    throw new Error("No such schema type: ".concat(typeName));
  }

  return type;
}

function getPairPermissions(_ref) {
  var permission = _ref.permission,
      draft = _ref.draft,
      published = _ref.published,
      liveEdit = _ref.liveEdit;
  // this was introduced because we ran into a bug where a user with publish
  // access was marked as not allowed to duplicate a document unless it had a
  // draft variant. this would happen in non-live edit cases where the document
  // pair only had a published variant with the draft variant being null.
  //
  // note: this should _not_ be used if the draft and published versions should
  // be considered separately/explicitly in the permissions.
  var effectiveVersion = draft || published;
  var effectiveVersionType = effectiveVersion === draft ? 'draft' : 'published';

  switch (permission) {
    case 'delete':
      {
        if (liveEdit) {
          return [['delete published document (live-edit)', checkDocumentPermission('update', published)]];
        }

        return [['delete draft document', checkDocumentPermission('update', draft)], ['delete published document', checkDocumentPermission('update', published)]];
      }

    case 'discardDraft':
      {
        if (liveEdit) return [];
        return [['delete draft document', checkDocumentPermission('update', draft)]];
      }

    case 'publish':
      {
        if (liveEdit) return [];
        return [// precondition
        ['update published document at its current state', checkDocumentPermission('update', published)], // post condition
        ['delete draft document', checkDocumentPermission('update', draft)], ['create published document from draft', checkDocumentPermission('create', draft && _objectSpread(_objectSpread({}, draft), {}, {
          _id: (0, _draftUtils.getPublishedId)(draft._id)
        }))]];
      }

    case 'unpublish':
      {
        if (liveEdit) return [];
        return [// precondition
        ['update draft document at its current state', checkDocumentPermission('create', draft)], // post condition
        ['delete published document', checkDocumentPermission('update', published)], ['create draft document from published version', checkDocumentPermission('create', published && _objectSpread(_objectSpread({}, published), {}, {
          _id: (0, _draftUtils.getDraftId)(published._id)
        }))]];
      }

    case 'update':
      {
        if (liveEdit) {
          return [['update published document (live-edit)', checkDocumentPermission('update', published)]];
        }

        return [["update ".concat(effectiveVersionType, " document"), checkDocumentPermission('update', effectiveVersion)]];
      }

    case 'duplicate':
      {
        if (liveEdit) {
          return [['create new published document from existing document (live-edit)', checkDocumentPermission('create', _objectSpread(_objectSpread({}, published), {}, {
            _id: 'dummy-id'
          }))]];
        }

        return [["create new draft document from existing ".concat(effectiveVersionType, " document"), checkDocumentPermission('create', _objectSpread(_objectSpread({}, effectiveVersion), {}, {
          _id: (0, _draftUtils.getDraftId)('dummy-id')
        }))]];
      }

    default:
      {
        throw new Error("Could not match permission: ".concat(permission));
      }
  }
}

/**
 * The observable version of `useDocumentPairPermissions`
 *
 * @see useDocumentPairPermissions
 */
function getDocumentPairPermissions(_ref2) {
  var id = _ref2.id,
      type = _ref2.type,
      permission = _ref2.permission;

  // this case was added to fix a crash that would occur if the `schemaType` was
  // omitted from `S.documentList()`
  //
  // see `resolveTypeForDocument` which returns `'*'` if no type is provided
  // https://github.com/sanity-io/sanity/blob/4d49b83a987d5097064d567f75d21b268a410cbf/packages/%40sanity/base/src/datastores/document/resolveTypeForDocument.ts#L7
  if (type === '*') {
    return (0, _rxjs.of)({
      granted: false,
      reason: 'Type specified was `*`'
    });
  }

  var liveEdit = Boolean(getSchemaType(type).liveEdit);
  return (0, _snapshotPair.snapshotPair)({
    draftId: (0, _draftUtils.getDraftId)(id),
    publishedId: (0, _draftUtils.getPublishedId)(id)
  }, type).pipe((0, _operators.switchMap)(pair => (0, _rxjs.combineLatest)([pair.draft.snapshots$, pair.published.snapshots$]).pipe((0, _operators.map)(_ref3 => {
    var _ref4 = _slicedToArray(_ref3, 2),
        draft = _ref4[0],
        published = _ref4[1];

    return {
      draft,
      published
    };
  }))), (0, _operators.switchMap)(_ref5 => {
    var draft = _ref5.draft,
        published = _ref5.published;
    var pairPermissions = getPairPermissions({
      permission,
      draft,
      published,
      liveEdit
    }).map(_ref6 => {
      var _ref7 = _slicedToArray(_ref6, 2),
          label = _ref7[0],
          observable = _ref7[1];

      return observable.pipe((0, _operators.map)(_ref8 => {
        var granted = _ref8.granted,
            reason = _ref8.reason;
        return {
          granted,
          reason: granted ? '' : "not allowed to ".concat(label, ": ").concat(reason),
          label,
          permission
        };
      }));
    });
    if (!pairPermissions.length) return (0, _rxjs.of)({
      granted: true,
      reason: ''
    });
    return (0, _rxjs.combineLatest)(pairPermissions).pipe((0, _operators.map)(permissionResults => {
      var granted = permissionResults.every(permissionResult => permissionResult.granted);
      var reason = granted ? '' : "Unable to ".concat(permission, ":\n\t").concat(permissionResults.filter(permissionResult => !permissionResult.granted).map(permissionResult => permissionResult.reason).join('\n\t'));
      return {
        granted,
        reason
      };
    }));
  }));
}
/**
 * Gets document pair permissions based on a document ID and a type.
 *
 * This permissions API is a high-level permissions API that is draft-model
 * aware. In order to determine whether or not the user has the given
 * permission, both the draft and published documents are pulled and run through
 * all of the user's grants. If any pre or post conditions fail a permissions
 * checks, the operations will not be granted.
 *
 * The operations this hook accepts are only relevant to document pairs. E.g.
 * `'create'` is not included as an operation because it's not possible to tell
 * if a document can be created by only using the initial ID and type because an
 * initial template value may not have a matching grant (e.g. locked-document
 * pattern `!locked`). In contrast, the operation `'duplicate'` is supported
 * because the draft value of the document can be live queried and checked for
 * matching grants.
 *
 * Note: for live-edit documents, non-applicable operations (e.g. publish) will
 * return as true.
 *
 * @see useDocumentValuePermissions
 */


var useDocumentPairPermissions = (0, _createHookFromObservableFactory.createHookFromObservableFactory)(getDocumentPairPermissions);
exports.unstable_useDocumentPairPermissions = useDocumentPairPermissions;