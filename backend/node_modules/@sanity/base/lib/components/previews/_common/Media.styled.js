"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MediaWrapper = void 0;

var _ui = require("@sanity/ui");

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _constants = require("../constants");

var _templateObject;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var MediaWrapper = _styledComponents.default.span(props => {
  var $dimensions = props.$dimensions,
      $layout = props.$layout,
      $radius = props.$radius,
      $responsive = props.$responsive;
  var width = $dimensions.width;
  var height = $dimensions.width;
  var iconSize = _constants.PREVIEW_ICON_SIZE[$layout];
  return (0, _styledComponents.css)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    position: relative;\n    width: ", ";\n    height: ", ";\n    min-width: ", ";\n    border-radius: ", ";\n    display: flex;\n    align-items: center;\n    justify-content: center;\n\n    & img {\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      object-fit: contain;\n      border-radius: inherit;\n    }\n\n    & svg {\n      display: block;\n      font-size: calc(21 / 16 * 1em);\n    }\n\n    & [data-sanity-icon] {\n      display: block;\n      font-size: calc(", " / 16 * 1em);\n    }\n\n    /*\n      NOTE on why we can\u2019t use the \":after\" pseudo-element:\n      The thing is we only want the shadow when then <MediaWrapper> contains\n      something else than <svg> \u2013 icons should not have the shadow.\n      This is why we use the \"*:not(svg) + span\" selector to target only that\n      situation to render the shadow.\n    */\n    & *:not(svg) + span {\n      display: block;\n      position: absolute;\n      left: 0;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      box-shadow: inset 0 0 0 1px var(--card-fg-color);\n      opacity: 0.2;\n      border-radius: inherit;\n    }\n  "])), $responsive ? '100%' : (0, _ui.rem)(width), $responsive ? '100%' : (0, _ui.rem)(height), $responsive ? undefined : (0, _ui.rem)(width), _ref => {
    var theme = _ref.theme;
    return (0, _ui.rem)(theme.sanity.radius[$radius]);
  }, iconSize);
});

exports.MediaWrapper = MediaWrapper;
MediaWrapper.displayName = 'MediaWrapper';