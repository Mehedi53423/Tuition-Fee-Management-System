"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkModuleStatus = checkModuleStatus;
exports.getInstalledModuleVersion = getInstalledModuleVersion;

var _operators = require("rxjs/operators");

var _legacyParts = require("../legacyParts");

var _versionedClient = require("../client/versionedClient");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Used to keep track of lookups to prevent multiple requests
var CACHED_LOOKUPS = new Map();
/**
 * Retrieve whether or not the installed (or passed) `@sanity`-modules are up
 * to date and/or supported, and if they are outdated; which versions are is
 * the latest available on npm vs which ones are installed locally.
 *
 * @param options Options to use for resolving module status
 * @internal Not a stable API yet
 */

function checkModuleStatus(options) {
  var _ref = options || {},
      _ref$moduleVersions = _ref.moduleVersions,
      moduleVersions = _ref$moduleVersions === void 0 ? getInstalledModules() : _ref$moduleVersions,
      _ref$client = _ref.client,
      client = _ref$client === void 0 ? _versionedClient.versionedClient : _ref$client;

  var query = buildQueryString(moduleVersions);
  var hash = hashQuery(query.m);
  var request$ = CACHED_LOOKUPS.get(hash);

  if (request$) {
    return request$;
  }

  request$ = client.observable.request({
    url: '/versions',
    query,
    json: true,
    tag: 'module.version-check'
  }).pipe((0, _operators.map)(result => _objectSpread(_objectSpread({}, result), {}, {
    installed: moduleVersions
  })), (0, _operators.shareReplay)(1));
  CACHED_LOOKUPS.set(hash, request$);
  return request$;
}
/**
 * Returns the currently installed version of the given module
 *
 * @param moduleName Name of module to get version number for
 * @internal Not a stable API yet
 */


function getInstalledModuleVersion(moduleName) {
  var versions = getInstalledModules();
  return versions[moduleName];
}
/**
 * Builds to: {m: ['@sanity/base@2.14.0', '@sanity/desk-tool@2.13.4']}
 * Serializes to: ?m=@sanity/base@2.14.0&m=@sanity/desk-tool@2.13.4
 */


function buildQueryString(versions) {
  return {
    m: Object.keys(versions).sort().filter(pkg => versions[pkg]).map(pkg => "".concat(pkg, "@").concat(versions[pkg]))
  };
}
/**
 * Returns an object of installed `@sanity`-modules and their installed version numbers
 */


function getInstalledModules() {
  // Ugly hack, but this allows for testing the version checker even when running
  // the latest module versions, by pretending we're using an outdated module
  var fakeOutdatedModule = false;

  if (fakeOutdatedModule) {
    return _objectSpread(_objectSpread({}, _legacyParts.sanityModuleVersions), {}, {
      '@sanity/base': '1.118.0'
    });
  }

  return _legacyParts.sanityModuleVersions;
}
/**
 * Reduce the module array string by stripping sanity-prefixes and joining them together
 */


function hashQuery(items) {
  return items.join(',').replace(/@?sanity[/-]/g, '');
}