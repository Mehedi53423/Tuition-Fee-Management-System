"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isStateUpdateEvent = isStateUpdateEvent;
exports.navigate = navigate;
exports.state = void 0;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _location = _interopRequireDefault(require("part:@sanity/base/location"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _router = _interopRequireDefault(require("../router"));

var _getOrderedTools = _interopRequireDefault(require("../util/getOrderedTools"));

var _reconfigureClient = _interopRequireDefault(require("../util/reconfigureClient"));

var _spaces = require("../util/spaces");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function resolveUrlStateWithDefaultSpace(state) {
  if (!_spaces.HAS_SPACES || !state || state.space) {
    return state;
  }

  var defaultSpace = _spaces.CONFIGURED_SPACES.find(ds => ds.default) || _spaces.CONFIGURED_SPACES[0];

  return Object.assign({}, state, {
    space: defaultSpace.name
  });
}

function resolveUrlStateWithDefaultTool(state) {
  var defaultTool = (0, _getOrderedTools.default)()[0];

  if (!state || state.tool || !defaultTool) {
    return state;
  }

  return Object.assign({}, state, {
    tool: defaultTool.name
  });
}

function makeBackwardsCompatible(state) {
  if (!state) {
    return state;
  }

  if ((0, _getOrderedTools.default)().find(tool => tool.name === state.space)) {
    return Object.assign({}, state, {
      tool: state.space,
      space: undefined
    });
  }

  return state;
}

function resolveDefaultState(state) {
  var urlStateWithDefaultTool = resolveUrlStateWithDefaultTool(makeBackwardsCompatible(state));
  return _spaces.HAS_SPACES ? resolveUrlStateWithDefaultSpace(urlStateWithDefaultTool) : urlStateWithDefaultTool;
}

function resolveIntentState(currentState, intentState) {
  var intent = intentState.intent,
      params = intentState.params,
      payload = intentState.payload;
  var tools = (0, _getOrderedTools.default)();
  var currentTool = currentState.tool ? tools.find(tool => tool.name === currentState.tool) : null; // If current tool can handle intent and if so, give it precedence

  var matchingTool = (currentTool ? [currentTool, ...tools] : tools).find(tool => tool && typeof tool.canHandleIntent === 'function' && tool.canHandleIntent(intent, params, currentState[tool.name]));

  if (matchingTool !== null && matchingTool !== void 0 && matchingTool.getIntentState) {
    var toolState = matchingTool.getIntentState(intent, params, currentState[matchingTool.name], payload);
    var currentWithState = resolveUrlStateWithDefaultSpace(currentState) || currentState;
    return Object.assign({}, currentWithState, {
      tool: matchingTool.name,
      [matchingTool.name]: toolState
    });
  }

  return {
    isNotFound: true,
    intent: {
      name: intent,
      params
    }
  };
}

function maybeHandleIntent(prevEvent, currentEvent) {
  if (currentEvent && currentEvent.state && currentEvent.state.intent) {
    var redirectState = resolveIntentState(prevEvent ? prevEvent.state : {}, currentEvent.state);

    if (redirectState) {
      var newUrl = _router.default.encode(redirectState);

      setTimeout(() => navigate(newUrl, {
        replace: true
      }), 0);
      return null;
    }
  }

  return currentEvent;
}

function decodeUrlState(locationEvent) {
  return {
    type: locationEvent.type,
    state: _router.default.decode(location.pathname),
    isNotFound: _router.default.isNotFound(location.pathname)
  };
}

function maybeRedirectDefaultState(event) {
  var redirectState = resolveDefaultState(event.state);

  if (redirectState !== event.state) {
    navigate(_router.default.encode(redirectState), {
      replace: true
    });
    return null;
  }

  return event;
}

function navigate(newUrl, options) {
  _location.default.actions.navigate(newUrl, options);
}

var state = _location.default.state.pipe((0, _operators.map)(decodeUrlState), (0, _operators.scan)(maybeHandleIntent, null), (0, _operators.filter)(Boolean), (0, _operators.map)(maybeRedirectDefaultState), (0, _operators.filter)(Boolean), (0, _operators.distinctUntilChanged)(_isEqual2.default), (0, _operators.catchError)(err => (0, _rxjs.of)({
  type: 'error',
  error: err
})), (0, _operators.publishReplay)(1), (0, _operators.refCount)());

exports.state = state;

function isStateUpdateEvent(event) {
  return event.type === 'snapshot' || event.type === 'change';
}

if (_spaces.HAS_SPACES) {
  // Uglybugly mutation ahead.
  state.pipe((0, _operators.filter)(isStateUpdateEvent), (0, _operators.map)(event => event.state), (0, _operators.filter)(Boolean), (0, _operators.tap)(_reconfigureClient.default)).subscribe();
}