"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWithEditableAPI = createWithEditableAPI;

var _slate = require("slate");

var _slateReact = require("@sanity/slate-react");

var _values = require("../../utils/values");

var _ranges = require("../../utils/ranges");

var _debug = require("../../utils/debug");

var _weakMaps = require("../../utils/weakMaps");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var debug = (0, _debug.debugWithName)('API:editable');

function createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator) {
  return function withEditableAPI(editor) {
    portableTextEditor.setEditable({
      focus: () => {
        // Make a selection if missing
        if (!editor.selection) {
          var point = {
            path: [0, 0],
            offset: 0
          };

          _slate.Transforms.select(editor, {
            focus: point,
            anchor: point
          });

          editor.onChange();
        }

        _slateReact.ReactEditor.focus(editor);
      },
      blur: () => {
        _slateReact.ReactEditor.blur(editor);
      },
      toggleMark: mark => {
        editor.pteToggleMark(mark);
      },
      toggleList: listStyle => {
        editor.pteToggleListItem(listStyle);
      },
      toggleBlockStyle: blockStyle => {
        editor.pteToggleBlockStyle(blockStyle);
      },
      isMarkActive: mark => {
        // Try/catch this, as Slate may error because the selection is currently wrong
        // TODO: catch only relevant error from Slate
        try {
          return editor.pteIsMarkActive(mark);
        } catch (err) {
          console.warn(err);
          return false;
        }
      },
      marks: () => {
        return _objectSpread({}, _slate.Editor.marks(editor) || {}).marks || [];
      },
      undo: () => editor.undo(),
      redo: () => editor.redo(),
      select: selection => {
        var slateSelection = (0, _ranges.toSlateRange)(selection, editor);

        if (slateSelection) {
          _slate.Transforms.select(editor, slateSelection);
        } else {
          _slate.Transforms.deselect(editor);
        }

        editor.onChange();
      },
      focusBlock: () => {
        if (editor.selection) {
          // Try/catch this, as Slate may error because the selection is currently wrong
          // TODO: catch only relevant error from Slate
          try {
            var _ref = Array.from(_slate.Editor.nodes(editor, {
              at: editor.selection.focus,
              match: n => _slate.Editor.isBlock(editor, n)
            }))[0] || [undefined],
                _ref2 = _slicedToArray(_ref, 1),
                block = _ref2[0];

            if (block) {
              return (0, _values.fromSlateValue)([block], portableTextFeatures.types.block.name, _weakMaps.KEY_TO_VALUE_ELEMENT.get(editor))[0];
            }
          } catch (err) {
            return undefined;
          }
        }

        return undefined;
      },
      focusChild: () => {
        if (editor.selection) {
          try {
            var _ref3 = Array.from(_slate.Editor.nodes(editor, {
              mode: 'lowest',
              at: editor.selection.focus,
              match: n => n._type !== undefined,
              voids: true
            }))[0] || [undefined],
                _ref4 = _slicedToArray(_ref3, 1),
                node = _ref4[0];

            if (node && !_slate.Editor.isBlock(editor, node)) {
              var pseudoBlock = {
                _key: 'pseudo',
                _type: portableTextFeatures.types.block.name,
                children: [node]
              };
              return (0, _values.fromSlateValue)([pseudoBlock], portableTextFeatures.types.block.name, _weakMaps.KEY_TO_VALUE_ELEMENT.get(editor))[0].children[0];
            }
          } catch (err) {
            return undefined;
          }
        }

        return undefined;
      },
      insertChild: (type, value) => {
        var _toPortableTextRange;

        if (!editor.selection) {
          throw new Error('The editor has no selection');
        }

        var _ref5 = Array.from(_slate.Editor.nodes(editor, {
          at: editor.selection.focus,
          match: n => _slate.Editor.isBlock(editor, n)
        }))[0] || [undefined],
            _ref6 = _slicedToArray(_ref5, 1),
            focusBlock = _ref6[0];

        if (!focusBlock) {
          throw new Error('No focus block');
        }

        if (focusBlock && _slate.Editor.isVoid(editor, focusBlock)) {
          throw new Error("Can't insert childs into block objects");
        }

        var block = (0, _values.toSlateValue)([{
          _key: keyGenerator(),
          _type: portableTextFeatures.types.block.name,
          children: [_objectSpread({
            _key: keyGenerator(),
            _type: type.name
          }, value ? value : {})]
        }], portableTextEditor)[0];
        var child = block.children[0];

        _slate.Editor.insertNode(editor, child);

        editor.onChange();
        return ((_toPortableTextRange = (0, _ranges.toPortableTextRange)(editor, editor.selection)) === null || _toPortableTextRange === void 0 ? void 0 : _toPortableTextRange.focus.path) || [];
      },
      insertBlock: (type, value) => {
        var _toPortableTextRange2;

        if (!editor.selection) {
          throw new Error('The editor has no selection');
        }

        var block = (0, _values.toSlateValue)([_objectSpread({
          _key: keyGenerator(),
          _type: type.name
        }, value ? value : {})], portableTextEditor)[0];

        _slate.Editor.insertNode(editor, block);

        editor.onChange();
        return ((_toPortableTextRange2 = (0, _ranges.toPortableTextRange)(editor, editor.selection)) === null || _toPortableTextRange2 === void 0 ? void 0 : _toPortableTextRange2.focus.path) || [];
      },
      hasBlockStyle: style => {
        try {
          return editor.pteHasBlockStyle(style);
        } catch (err) {
          // This is fine.
          // debug(err)
          return false;
        }
      },
      hasListStyle: listStyle => {
        try {
          return editor.pteHasListStyle(listStyle);
        } catch (err) {
          // This is fine.
          // debug(err)
          return false;
        }
      },
      isVoid: element => {
        return ![portableTextFeatures.types.block.name, portableTextFeatures.types.span.name].includes(element._type);
      },
      findByPath: path => {
        var slatePath = (0, _ranges.toSlateRange)({
          focus: {
            path,
            offset: 0
          },
          anchor: {
            path,
            offset: 0
          }
        }, editor);

        if (slatePath) {
          var _Editor$node = _slate.Editor.node(editor, slatePath.focus.path.slice(0, 1)),
              _Editor$node2 = _slicedToArray(_Editor$node, 2),
              block = _Editor$node2[0],
              blockPath = _Editor$node2[1];

          if (block && blockPath && typeof block._key === 'string') {
            if (path.length === 1 && slatePath.focus.path.length === 1) {
              return [(0, _values.fromSlateValue)([block], portableTextFeatures.types.block.name)[0], [{
                _key: block._key
              }]];
            }

            var ptBlock = (0, _values.fromSlateValue)([block], portableTextFeatures.types.block.name, _weakMaps.KEY_TO_VALUE_ELEMENT.get(editor))[0];
            var ptChild = ptBlock.children[slatePath.focus.path[1]];

            if (ptChild) {
              return [ptChild, [{
                _key: block._key
              }, 'children', {
                _key: ptChild._key
              }]];
            }
          }
        }

        return [undefined, undefined];
      },
      findDOMNode: element => {
        var node;

        try {
          var _ref7 = Array.from(_slate.Editor.nodes(editor, {
            at: [],
            match: n => n._key === element._key
          }) || [])[0] || [undefined],
              _ref8 = _slicedToArray(_ref7, 1),
              item = _ref8[0];

          node = _slateReact.ReactEditor.toDOMNode(editor, item);
        } catch (err) {// Nothing
        }

        return node;
      },
      activeAnnotations: () => {
        if (!editor.selection || editor.selection.focus.path.length < 2) {
          return [];
        }

        try {
          var _ret = function () {
            var activeAnnotations = [];

            var spans = _slate.Editor.nodes(editor, {
              at: editor.selection,
              match: node => _slate.Text.isText(node) && node.marks !== undefined && Array.isArray(node.marks) && node.marks.length > 0
            });

            var _iterator = _createForOfIteratorHelper(spans),
                _step;

            try {
              var _loop = function _loop() {
                var _step$value = _slicedToArray(_step.value, 2),
                    span = _step$value[0],
                    path = _step$value[1];

                var _Editor$node3 = _slate.Editor.node(editor, path, {
                  depth: 1
                }),
                    _Editor$node4 = _slicedToArray(_Editor$node3, 1),
                    block = _Editor$node4[0];

                if (editor.isTextBlock(block)) {
                  block.markDefs.forEach(def => {
                    if (_slate.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key)) {
                      activeAnnotations.push(def);
                    }
                  });
                }
              };

              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                _loop();
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            return {
              v: activeAnnotations
            };
          }();

          if (typeof _ret === "object") return _ret.v;
        } catch (err) {
          return [];
        }
      },
      addAnnotation: (type, value) => {
        var selection = editor.selection;

        if (selection) {
          var _Editor$node5 = _slate.Editor.node(editor, selection.focus, {
            depth: 1
          }),
              _Editor$node6 = _slicedToArray(_Editor$node5, 1),
              block = _Editor$node6[0];

          if (_slate.Element.isElement(block) && block._type === portableTextFeatures.types.block.name) {
            var annotationKey = keyGenerator();

            if (editor.isTextBlock(block)) {
              _slate.Transforms.setNodes(editor, {
                markDefs: [...block.markDefs, _objectSpread({
                  _type: type.name,
                  _key: annotationKey
                }, value)]
              }, {
                at: selection.focus
              });

              editor.onChange();

              if (_slate.Range.isCollapsed(selection)) {
                editor.pteExpandToWord();
                editor.onChange();
              }

              var _Editor$node7 = _slate.Editor.node(editor, selection.focus, {
                depth: 2
              }),
                  _Editor$node8 = _slicedToArray(_Editor$node7, 1),
                  textNode = _Editor$node8[0];

              if (editor.selection) {
                _slate.Editor.withoutNormalizing(editor, () => {
                  // Split if needed
                  _slate.Transforms.setNodes(editor, {}, {
                    match: _slate.Text.isText,
                    split: true
                  });

                  if (editor.selection && _slate.Text.isText(textNode)) {
                    _slate.Transforms.setNodes(editor, {
                      marks: [...(textNode.marks || []), annotationKey]
                    }, {
                      at: editor.selection,
                      match: n => n._type === portableTextFeatures.types.span.name
                    });

                    editor.onChange();
                  }
                });

                _slate.Editor.normalize(editor);

                editor.onChange();
                var newSelection = (0, _ranges.toPortableTextRange)(editor, editor.selection); // eslint-disable-next-line max-depth

                if (newSelection && typeof block._key === 'string') {
                  // Insert an empty string to continue writing non-annotated text
                  _slate.Editor.withoutNormalizing(editor, () => {
                    if (editor.selection) {
                      _slate.Transforms.insertNodes(editor, [{
                        _type: 'span',
                        text: '',
                        marks: [],
                        _key: keyGenerator()
                      }], {
                        at: _slate.Range.end(editor.selection)
                      });

                      editor.onChange();
                    }
                  });

                  return {
                    spanPath: newSelection.focus.path,
                    markDefPath: [{
                      _key: block._key
                    }, 'markDefs', {
                      _key: annotationKey
                    }]
                  };
                }
              }
            }
          }
        }

        return undefined;
      },
      delete: (selection, options) => {
        if (selection) {
          var range = (0, _ranges.toSlateRange)(selection, editor);

          if (range) {
            if (!(options !== null && options !== void 0 && options.mode) || (options === null || options === void 0 ? void 0 : options.mode) === 'selected') {
              debug("Deleting content in selection");

              _slate.Transforms.delete(editor, {
                at: range,
                hanging: true,
                voids: true
              });

              editor.onChange();
              return;
            }

            var nodes = _slate.Editor.nodes(editor, {
              at: range,
              match: node => {
                if ((options === null || options === void 0 ? void 0 : options.mode) === 'blocks') {
                  debug("Deleting blocks touched by selection");
                  return editor.isTextBlock(node) || !editor.isTextBlock(node) && _slate.Element.isElement(node);
                }

                debug("Deleting children touched by selection");
                return node._type === portableTextFeatures.types.span.name || // Text children
                !editor.isTextBlock(node) && _slate.Element.isElement(node) // inline blocks
                ;
              }
            });

            var nodeAndPaths = [...nodes];
            nodeAndPaths.forEach(_ref9 => {
              var _ref10 = _slicedToArray(_ref9, 2),
                  p = _ref10[1];

              _slate.Transforms.removeNodes(editor, {
                at: p,
                voids: true,
                hanging: true
              });
            });
            editor.onChange();
          }
        }
      },
      removeAnnotation: type => {
        var selection = editor.selection;
        debug('Removing annotation', type);

        if (selection) {
          // Select the whole annotation if collapsed
          if (_slate.Range.isCollapsed(selection)) {
            var _Editor$node9 = _slate.Editor.node(editor, selection, {
              depth: 2
            }),
                _Editor$node10 = _slicedToArray(_Editor$node9, 2),
                node = _Editor$node10[0],
                nodePath = _Editor$node10[1];

            if (_slate.Text.isText(node) && node.marks && typeof node.text === 'string') {
              _slate.Transforms.select(editor, nodePath);

              selection = editor.selection;
            }
          } // Do this without normalization or span references will be unstable!


          _slate.Editor.withoutNormalizing(editor, () => {
            if (selection && _slate.Range.isExpanded(selection)) {
              selection = editor.selection;

              if (!selection) {
                return;
              } // Split the span first


              _slate.Transforms.setNodes(editor, {}, {
                match: _slate.Text.isText,
                split: true
              });

              editor.onChange(); // Everything in the selection which has marks

              var spans = [..._slate.Editor.nodes(editor, {
                at: selection,
                match: node => _slate.Text.isText(node) && node.marks !== undefined && Array.isArray(node.marks) && node.marks.length > 0
              })];
              spans.forEach(_ref11 => {
                var _ref12 = _slicedToArray(_ref11, 2),
                    span = _ref12[0],
                    path = _ref12[1];

                var _Editor$node11 = _slate.Editor.node(editor, path, {
                  depth: 1
                }),
                    _Editor$node12 = _slicedToArray(_Editor$node11, 1),
                    block = _Editor$node12[0];

                if (editor.isTextBlock(block)) {
                  block.markDefs.filter(def => def._type === type.name).forEach(def => {
                    if (_slate.Text.isText(span) && Array.isArray(span.marks) && span.marks.includes(def._key)) {
                      var newMarks = [...(span.marks || []).filter(mark => mark !== def._key)];

                      _slate.Transforms.setNodes(editor, {
                        marks: newMarks
                      }, {
                        at: path,
                        voids: false,
                        split: false
                      });
                    }
                  });
                }
              });
            }
          });

          _slate.Editor.normalize(editor);

          editor.onChange();
        }
      },
      getSelection: () => {
        var ptRange = null;

        if (editor.selection) {
          var existing = _weakMaps.SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);

          if (existing) {
            return existing;
          }

          ptRange = (0, _ranges.toPortableTextRange)(editor, editor.selection);

          _weakMaps.SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
        }

        return ptRange;
      },
      getValue: () => {
        return (0, _values.fromSlateValue)(editor.children, portableTextFeatures.types.block.name, _weakMaps.KEY_TO_VALUE_ELEMENT.get(editor));
      },
      isCollapsedSelection: () => {
        return !!editor.selection && _slate.Range.isCollapsed(editor.selection);
      },
      isExpandedSelection: () => {
        return !!editor.selection && _slate.Range.isExpanded(editor.selection);
      }
    });
    return editor;
  };
}