"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findBlockAndIndexFromPath = findBlockAndIndexFromPath;
exports.findChildAndIndexFromPath = findChildAndIndexFromPath;
exports.fromSlateValue = fromSlateValue;
exports.isEqualToEmptyEditor = isEqualToEmptyEditor;
exports.toSlateValue = toSlateValue;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _slate = require("slate");

var _excluded = ["_type", "_key"],
    _excluded2 = ["_type", "_key"],
    _excluded3 = ["value", "_key", "_type", "__inline", "children"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var EMPTY_MARKDEFS = [];

function keepObjectEquality(object, keyMap) {
  var value = keyMap[object._key];

  if (value && (0, _isEqual2.default)(object, value)) {
    return value;
  }

  keyMap[object._key] = object;
  return object;
}

function toSlateValue(value, _ref) {
  var portableTextFeatures = _ref.portableTextFeatures;
  var keyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (value && Array.isArray(value)) {
    return value.map(block => {
      var _type = block._type,
          _key = block._key,
          rest = _objectWithoutProperties(block, _excluded);

      var voidChildren = [{
        _key: "".concat(_key, "-void-child"),
        _type: 'span',
        text: '',
        marks: []
      }];
      var isPortableText = block && block._type === portableTextFeatures.types.block.name;

      if (isPortableText) {
        var textBlock = block;
        var hasInlines = false;
        var hasMissingStyle = typeof textBlock.style === 'undefined';
        var hasMissingMarkDefs = typeof textBlock.markDefs === 'undefined';
        var children = textBlock.children.map(child => {
          var cType = child._type,
              cKey = child._key,
              cRest = _objectWithoutProperties(child, _excluded2);

          if (cType !== 'span') {
            hasInlines = true;
            return keepObjectEquality({
              _type: cType,
              _key: cKey,
              children: voidChildren,
              value: cRest,
              __inline: true
            }, keyMap);
          } // Original object


          return child;
        });

        if (!hasMissingStyle && !hasMissingMarkDefs && !hasInlines && _slate.Element.isElement(block)) {
          // Original object
          return block;
        }

        if (hasMissingStyle) {
          rest.style = portableTextFeatures.styles[0].value;
        }

        if (hasMissingMarkDefs) {
          rest.markDefs = EMPTY_MARKDEFS;
        }

        return keepObjectEquality(_objectSpread(_objectSpread({
          _type,
          _key
        }, rest), {}, {
          children
        }), keyMap);
      }

      return keepObjectEquality({
        _type,
        _key,
        children: voidChildren,
        value: rest
      }, keyMap);
    });
  }

  return [];
}

function fromSlateValue(value, textBlockType) {
  var keyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return value.map(block => {
    var _key = block._key,
        _type = block._type;

    if (!_key || !_type) {
      throw new Error('Not a valid block');
    }

    if (_type === textBlockType && 'children' in block && Array.isArray(block.children) && _key) {
      var hasInlines = false;
      var children = block.children.map(child => {
        var _cType = child._type;

        if ('value' in child && _cType !== 'span') {
          hasInlines = true; // eslint-disable-next-line @typescript-eslint/no-unused-vars

          var v = child.value,
              k = child._key,
              t = child._type,
              _i = child.__inline,
              _c = child.children,
              rest = _objectWithoutProperties(child, _excluded3);

          return keepObjectEquality(_objectSpread(_objectSpread(_objectSpread({}, rest), v), {}, {
            _key: k,
            _type: t
          }), keyMap);
        }

        return child;
      });

      if (!hasInlines) {
        return block; // Original object
      }

      return keepObjectEquality(_objectSpread(_objectSpread({}, block), {}, {
        children,
        _key,
        _type
      }), keyMap);
    }

    var blockValue = 'value' in block && block.value;
    return keepObjectEquality(_objectSpread({
      _key,
      _type
    }, typeof blockValue === 'object' ? blockValue : {}), keyMap);
  });
}

function isEqualToEmptyEditor(children, portableTextFeatures) {
  return children === undefined || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && _slate.Element.isElement(children[0]) && children[0]._type === portableTextFeatures.types.block.name && 'style' in children[0] && children[0].style === portableTextFeatures.styles[0].value && Array.isArray(children[0].children) && children[0].children.length === 1 && _slate.Text.isText(children[0].children[0]) && children[0].children[0]._type === 'span' && children[0].children[0].text === '';
}

function findBlockAndIndexFromPath(firstPathSegment, children) {
  var blockIndex = -1;
  var isNumber = Number.isInteger(Number(firstPathSegment));

  if (isNumber) {
    blockIndex = Number(firstPathSegment);
  } else if (children) {
    blockIndex = children.findIndex(blk => _slate.Element.isElement(blk) && (0, _isEqual2.default)({
      _key: blk._key
    }, firstPathSegment));
  }

  if (blockIndex > -1) {
    return [children[blockIndex], blockIndex];
  }

  return [undefined, -1];
}

function findChildAndIndexFromPath(secondPathSegment, block) {
  var childIndex = -1;
  var isNumber = Number.isInteger(Number(secondPathSegment));

  if (isNumber) {
    childIndex = Number(secondPathSegment);
  } else {
    childIndex = block.children.findIndex(child => (0, _isEqual2.default)({
      _key: child._key
    }, secondPathSegment));
  }

  if (childIndex > -1) {
    return [block.children[childIndex], childIndex];
  }

  return [undefined, -1];
}