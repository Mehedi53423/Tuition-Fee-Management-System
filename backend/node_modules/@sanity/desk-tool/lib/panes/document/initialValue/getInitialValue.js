"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInitialValueObservable = getInitialValueObservable;

var _initialValueTemplates = require("@sanity/base/initial-value-templates");

var _preview = require("part:@sanity/base/preview");

var _schema = _interopRequireDefault(require("part:@sanity/base/schema"));

var _draftUtils = require("part:@sanity/base/util/draft-utils");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LOADING_MSG = {
  type: 'loading'
};

/**
 * @internal
 */
function getInitialValueObservable(opts) {
  return (0, _rxjs.merge)((0, _preview.observePaths)((0, _draftUtils.getDraftId)(opts.documentId), ['_type']).pipe((0, _operators.map)(draft => ({
    draft
  }))), (0, _preview.observePaths)((0, _draftUtils.getPublishedId)(opts.documentId), ['_type']).pipe((0, _operators.map)(published => ({
    published
  })))).pipe((0, _operators.scan)((prev, res) => _objectSpread(_objectSpread({}, prev), res), {}), // Wait until we know the state of both draft and published
  (0, _operators.filter)(res => 'draft' in res && 'published' in res), (0, _operators.map)(res => res.draft || res.published), // Only update if we didn't previously have a document but we now do
  (0, _operators.distinctUntilChanged)((prev, next) => Boolean(prev) !== Boolean(next)), // Prevent rapid re-resolving when transitioning between different templates
  (0, _operators.debounceTime)(25), (0, _operators.switchMap)(document => {
    var _ref = getInitialValueProps(document || null, opts) || {},
        templateName = _ref.templateName,
        parameters = _ref.parameters;

    if (!templateName || !parameters) {
      var msg = {
        type: 'success',
        value: null
      };
      return (0, _rxjs.of)(msg);
    }

    return (0, _rxjs.merge)((0, _rxjs.of)({
      isResolving: true
    }), resolveInitialValueWithParameters(templateName, parameters).pipe( // @ts-expect-error NOTE: TypeScript fails for an unknown reason.
    (0, _operators.catchError)(resolveError => {
      /* eslint-disable no-console */
      console.group('Failed to resolve initial value');
      console.error(resolveError);
      console.error('Template ID: %s', templateName);
      console.error('Parameters: %o', parameters || {});
      console.groupEnd();
      /* eslint-enable no-console */

      var msg = {
        type: 'error',
        error: resolveError
      };
      return (0, _rxjs.of)(msg);
    }))).pipe((0, _operators.switchMap)(_ref2 => {
      var isResolving = _ref2.isResolving,
          initialValue = _ref2.initialValue,
          resolveError = _ref2.resolveError;

      if (resolveError) {
        return (0, _rxjs.of)({
          type: 'error',
          message: 'Failed to resolve initial value'
        });
      }

      if (isResolving) {
        return (0, _rxjs.of)(LOADING_MSG);
      }

      var msg = {
        type: 'success',
        value: initialValue
      };
      return (0, _rxjs.of)(msg);
    }));
  }), (0, _operators.startWith)(LOADING_MSG), (0, _operators.distinctUntilChanged)());
}
/**
 * @internal
 */


function getInitialValueProps(document, opts) {
  if (document) {
    return null;
  }

  var payload = opts.panePayload || {};
  var structureNodeTemplate = opts.paneOptions.template;

  if (opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate) {
    // eslint-disable-next-line no-console
    console.warn("Conflicting templates: URL says \"".concat(opts.urlTemplate, "\", structure node says \"").concat(structureNodeTemplate, "\". Using \"").concat(structureNodeTemplate, "\"."));
  }

  var template = structureNodeTemplate || opts.urlTemplate;
  var typeTemplates = (0, _initialValueTemplates.getTemplatesBySchemaType)(opts.paneOptions.type);

  var parameters = _objectSpread(_objectSpread({}, opts.paneOptions.templateParameters), typeof payload === 'object' ? payload || {} : {});

  var templateName = template; // If we have not specified a specific template, and we only have a single
  // template available for a schema type, use it

  if (!template && typeTemplates.length === 1) {
    templateName = typeTemplates[0].id;
  }

  return {
    templateName: templateName,
    parameters
  };
}
/**
 * @internal
 */


function resolveInitialValueWithParameters(templateName, parameters) {
  if (!(0, _initialValueTemplates.templateExists)(templateName)) {
    // eslint-disable-next-line no-console
    console.warn('Template "%s" not defined, using empty initial value', templateName);
    return (0, _rxjs.of)({
      isResolving: false,
      initialValue: undefined
    });
  }

  var tpl = (0, _initialValueTemplates.getTemplateById)(templateName);
  return (0, _rxjs.from)((0, _initialValueTemplates.resolveInitialValue)(_schema.default, tpl, parameters)).pipe((0, _operators.map)(initialValue => ({
    isResolving: false,
    initialValue
  })));
}