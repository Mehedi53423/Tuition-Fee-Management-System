import { Observable } from 'rxjs';
import { PaneNode, RouterPanes, RouterPaneSibling, UnresolvedPaneNode } from '../types';
import { PaneResolver } from './createPaneResolver';
/**
 * Represents one flattened "router pane", including the source group and
 * sibling indexes.
 *
 * @see RouterPanes
 */
interface FlattenedRouterPane {
    routerPaneSibling: RouterPaneSibling;
    flatIndex: number;
    groupIndex: number;
    siblingIndex: number;
}
/**
 * The state of the accumulator used to store and manage memo cache state
 */
interface CacheState {
    /**
     * Holds the memoization results keyed by a combination of `assignId` and a
     * context hash.
     */
    resolvedPaneCache: Map<string, Observable<PaneNode>>;
    /**
     * Acts as a dictionary that stores cache keys by their flat index. This is
     * used to clean up the cache between different branches in the pane
     * structure.
     *
     * @see createResolvedPaneNodeStream look inside the `scan` where `wrapFn` is
     * defined
     */
    cacheKeysByFlatIndex: Array<Set<string>>;
    /**
     * The resulting memoized `PaneResolver` function. This function closes over
     * the `resolvedPaneCache`.
     */
    resolvePane: PaneResolver;
    flattenedRouterPanes: FlattenedRouterPane[];
}
export interface CreateResolvedPaneNodeStreamOptions {
    /**
     * an input stream of `RouterPanes`
     * @see RouterPanes
     */
    routerPanesStream: Observable<RouterPanes>;
    /**
     * any `UnresolvedPaneNode` (could be an observable, promise, pane resolver etc)
     */
    rootPaneNode: UnresolvedPaneNode;
    /** used primarily for testing */
    initialCacheState?: CacheState;
}
/**
 * The result of pane resolving
 */
export declare type ResolvedPaneMeta = {
    groupIndex: number;
    siblingIndex: number;
    flatIndex: number;
    routerPaneSibling: RouterPaneSibling;
    path: string[];
} & ({
    type: 'loading';
    paneNode: null;
} | {
    type: 'resolvedMeta';
    paneNode: PaneNode;
});
/**
 * Takes in a stream of `RouterPanes` and an unresolved root pane and returns
 * a stream of `ResolvedPaneMeta`
 */
export declare function createResolvedPaneNodeStream({ routerPanesStream, rootPaneNode, initialCacheState, }: CreateResolvedPaneNodeStreamOptions): Observable<ResolvedPaneMeta[]>;
export {};
//# sourceMappingURL=createResolvedPaneNodeStream.d.ts.map