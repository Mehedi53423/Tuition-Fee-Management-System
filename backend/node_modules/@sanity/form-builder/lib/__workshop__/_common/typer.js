"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runTest = runTest;

var triggerInputEvent = (input, nextValue) => {
  var nativeInputValueSetter = Object.getOwnPropertyDescriptor(input.constructor.prototype, 'value').set;
  nativeInputValueSetter.call(input, nextValue);
  input.dispatchEvent(new Event('input', {
    bubbles: true
  }));
};

function format(string) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return string.replace(/{(\d+)}/g, function (match, index) {
    return typeof args[index] === 'undefined' ? match : args[index];
  });
}

var chars = 'abcdefghijklmnopqrstuvwxyz'.split('');

function runTest(props) {
  var inputElement = props.inputElement,
      _props$times = props.times,
      times = _props$times === void 0 ? 3 : _props$times,
      _props$gracePeriod = props.gracePeriod,
      gracePeriod = _props$gracePeriod === void 0 ? 4000 : _props$gracePeriod,
      onRun = props.onRun,
      onFinished = props.onFinished;
  var originalValue = inputElement.value;
  var total = 0;
  var sampleNo = 0;
  var remainingSamples = times;
  var handleRun = onRun;
  var timer;

  function cancelTimer() {
    if (timer) {
      clearTimeout(timer);
      return true;
    }

    return false;
  } // If we call `runTest` from within a React event handler, React will batch up any calls to setState happening
  // synchronously within the same call stack, and defer any re-render til the event handler completes
  // This means the first sample will be super fast because React will not re-render at all while it is running
  // For this reason we want to schedule the first sample async to escape the React event call stack


  Promise.resolve().then(sampleNext);

  if (!handleRun) {
    // eslint-disable-next-line no-console
    handleRun = console.log;
  }

  function sampleNext() {
    sampleNo++;
    remainingSamples--;
    var start = performance.now();
    chars.forEach(char => triggerInputEvent(inputElement, "Typing ".concat(char)));
    var duration = performance.now() - start;
    total += duration; // eslint-disable-next-line callback-return

    handleRun(format('Sample #{0}: {1}ms, avg: {2}ms', sampleNo, duration.toPrecision(4), (total / sampleNo).toPrecision(4)));

    if (remainingSamples > 0) {
      timer = setTimeout(sampleNext, gracePeriod);
    } else {
      // eslint-disable-next-line callback-return
      handleRun(format('Average of {0} samples: {1}ms', sampleNo, (total / sampleNo).toPrecision(4)));
      onFinished();
      triggerInputEvent(inputElement, originalValue);
    }
  }

  return cancelTimer;
}