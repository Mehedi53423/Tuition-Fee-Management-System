"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _uniqueId2 = _interopRequireDefault(require("lodash/uniqueId"));

var _groupBy2 = _interopRequireDefault(require("lodash/groupBy"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _components = require("@sanity/base/components");

var _ui = require("@sanity/ui");

var _changeIndicators = require("@sanity/base/change-indicators");

var _icons = require("@sanity/icons");

var _react = _interopRequireDefault(require("react"));

var _presence = require("@sanity/base/presence");

var _reactFastCompare = _interopRequireDefault(require("react-fast-compare"));

var _ImageToolInput = require("../ImageToolInput");

var _PatchEvent = _interopRequireWildcard(require("../../../PatchEvent"));

var _UploadPlaceholder = _interopRequireDefault(require("../common/UploadPlaceholder"));

var _WithReferencedAsset = require("../../../utils/WithReferencedAsset");

var _styles = require("../common/styles");

var _UploadProgress = require("../common/UploadProgress");

var _empty = require("../../../utils/empty");

var _assetSource = require("../common/assetSource");

var _ActionsMenu = require("../common/ActionsMenu");

var _resolveUploader = _interopRequireDefault(require("../../../sanity/uploads/resolveUploader"));

var _UploadWarning = require("../common/UploadWarning");

var _ImagePreview = require("./ImagePreview");

var _ImageInputField = require("./ImageInputField");

var _ImageActionsMenu = require("./ImageActionsMenu");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var getDevicePixelRatio = () => {
  if (typeof window === 'undefined' || !window.devicePixelRatio) {
    return 1;
  }

  return Math.round(Math.max(1, window.devicePixelRatio));
};

var EMPTY_FIELD_GROUPS = {
  asset: [],
  imagetool: [],
  highlighted: [],
  dialog: [],
  imageToolAndDialog: []
};
var ASSET_FIELD_PATH = ['asset'];

class ImageInput extends _react.default.PureComponent {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "_inputId", (0, _uniqueId2.default)('ImageInput'));

    _defineProperty(this, "_assetElementRef", null);

    _defineProperty(this, "_fieldGroupsMemo", null);

    _defineProperty(this, "uploadSubscription", null);

    _defineProperty(this, "state", {
      isUploading: false,
      selectedAssetSource: null,
      hoveringFiles: [],
      isStale: false,
      isMenuOpen: false
    });

    _defineProperty(this, "toast", null);

    _defineProperty(this, "setFocusElement", el => {
      this._assetElementRef = el;
    });

    _defineProperty(this, "getUploadOptions", file => {
      var type = this.props.type;
      var uploader = _resolveUploader.default && (0, _resolveUploader.default)(type, file);
      return uploader ? [{
        type: type,
        uploader
      }] : [];
    });

    _defineProperty(this, "uploadWith", function (uploader, file) {
      var assetDocumentProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var _this$props = _this.props,
          type = _this$props.type,
          onChange = _this$props.onChange;
      var label = assetDocumentProps.label,
          title = assetDocumentProps.title,
          description = assetDocumentProps.description,
          creditLine = assetDocumentProps.creditLine,
          source = assetDocumentProps.source;
      var options = {
        metadata: (0, _get2.default)(type, 'options.metadata'),
        storeOriginalFilename: (0, _get2.default)(type, 'options.storeOriginalFilename'),
        label,
        title,
        description,
        creditLine,
        source
      };

      _this.cancelUpload();

      _this.setState({
        isUploading: true
      });

      onChange(_PatchEvent.default.from([(0, _PatchEvent.setIfMissing)({
        _type: type.name
      })]));
      _this.uploadSubscription = uploader.upload(file, type, options).subscribe({
        next: uploadEvent => {
          if (uploadEvent.patches) {
            onChange(_PatchEvent.default.from(uploadEvent.patches));
          }
        },
        error: err => {
          var _this$toast;

          // eslint-disable-next-line no-console
          console.error(err);
          (_this$toast = _this.toast) === null || _this$toast === void 0 ? void 0 : _this$toast.push({
            status: 'error',
            description: 'The upload could not be completed at this time.',
            title: 'Upload failed'
          });

          _this.clearUploadStatus();
        },
        complete: () => {
          onChange(_PatchEvent.default.from([(0, _PatchEvent.unset)(['hotspot']), (0, _PatchEvent.unset)(['crop'])]));

          _this.setState({
            isUploading: false
          }); // this.toast.push({
          //   status: 'success',
          //   title: 'Upload completed',
          // })

        }
      });
    });

    _defineProperty(this, "handleRemoveButtonClick", () => {
      var value = this.props.value; // When removing the image, we should also remove any crop and hotspot
      // _type and _key are "meta"-properties and are not significant unless
      // other properties are present. Thus, we want to remove the entire
      // "container" object if these are the only properties present, BUT
      // only if we're not an array element, as removing the array element
      // will close the selection dialog. Instead, when closing the dialog,
      // the array logic will check for an "empty" value and remove it for us

      var allKeys = Object.keys(value || {});
      var remainingKeys = allKeys.filter(key => !['_type', '_key', '_upload', 'asset', 'crop', 'hotspot'].includes(key));
      var isEmpty = remainingKeys.length === 0;
      var removeKeys = ['asset'].concat(allKeys.filter(key => ['crop', 'hotspot', '_upload'].includes(key))).map(key => (0, _PatchEvent.unset)([key]));
      this.props.onChange(_PatchEvent.default.from(isEmpty && !this.valueIsArrayElement() ? (0, _PatchEvent.unset)() : removeKeys));
    });

    _defineProperty(this, "handleFieldChange", event => {
      var _this$props2 = this.props,
          onChange = _this$props2.onChange,
          type = _this$props2.type; // When editing a metadata field for an image (eg `altText`), and no asset
      // is currently selected, we want to unset the entire image field if the
      // field we are currently editing goes blank and gets unset.
      //
      // For instance:
      // An image field with an `altText` and a `title` subfield, where the image
      // `asset` and the `title` field is empty, and we are erasing the `alt` field.
      // We do _not_ however want to clear the field if any content is present in
      // the other fields - but we do not consider `crop` and `hotspot`.
      //
      // Also, we don't want to use this logic for array items, since the parent will
      // take care of it when closing the array dialog

      if (!this.valueIsArrayElement() && this.eventIsUnsettingLastFilledField(event)) {
        onChange(_PatchEvent.default.from((0, _PatchEvent.unset)()));
        return;
      }

      onChange(event.prepend((0, _PatchEvent.setIfMissing)({
        _type: type.name
      })));
    });

    _defineProperty(this, "eventIsUnsettingLastFilledField", event => {
      var patch = event.patches[0];

      if (event.patches.length !== 1 || patch.type !== 'unset') {
        return false;
      }

      var allKeys = Object.keys(this.props.value || {});
      var remainingKeys = allKeys.filter(key => !['_type', '_key', 'crop', 'hotspot'].includes(key));
      var isEmpty = event.patches[0].path.length === 1 && remainingKeys.length === 1 && remainingKeys[0] === event.patches[0].path[0];
      return isEmpty;
    });

    _defineProperty(this, "valueIsArrayElement", () => {
      var getValuePath = this.props.getValuePath;
      var parentPathSegment = getValuePath().slice(-1)[0]; // String path segment mean an object path, while a number or a
      // keyed segment means we're a direct child of an array

      return typeof parentPathSegment !== 'string';
    });

    _defineProperty(this, "handleOpenDialog", () => {
      var _this$props3 = this.props,
          type = _this$props3.type,
          onFocus = _this$props3.onFocus;
      var groups = this.getGroupedFields(type);
      var firstDialogField = this.isImageToolEnabled() ? groups.imagetool[0] : groups.dialog[0];

      if (firstDialogField) {
        onFocus([firstDialogField.name]);
      }
    });

    _defineProperty(this, "handleCloseDialog", () => {
      this.props.onFocus([]);
    });

    _defineProperty(this, "handleSelectAssetFromSource", assetFromSource => {
      var _this$props4 = this.props,
          onChange = _this$props4.onChange,
          type = _this$props4.type;
      (0, _assetSource.handleSelectAssetFromSource)({
        assetFromSource,
        onChange,
        type,
        resolveUploader: _resolveUploader.default,
        uploadWith: this.uploadWith,
        isImage: true
      });
      this.setState({
        selectedAssetSource: null
      });
    });

    _defineProperty(this, "handleFileTargetFocus", () => {
      this.props.onFocus(['asset']);
    });

    _defineProperty(this, "handleFileTargetBlur", () => {
      this.props.onBlur();
    });

    _defineProperty(this, "handleFilesOver", hoveringFiles => {
      this.setState({
        hoveringFiles
      });
    });

    _defineProperty(this, "handleFilesOut", () => {
      this.setState({
        hoveringFiles: []
      });
    });

    _defineProperty(this, "handleCancelUpload", () => {
      this.cancelUpload();
    });

    _defineProperty(this, "handleClearUploadState", () => {
      this.setState({
        isStale: false
      });
      this.clearUploadStatus();
    });

    _defineProperty(this, "handleStaleUpload", () => {
      this.setState({
        isStale: true
      });
    });

    _defineProperty(this, "handleSelectFiles", files => {
      var _this$props5 = this.props,
          directUploads = _this$props5.directUploads,
          readOnly = _this$props5.readOnly;
      var hoveringFiles = this.state.hoveringFiles;

      if (directUploads && !readOnly) {
        this.uploadFirstAccepted(files);
      } else if (hoveringFiles.length > 0) {
        this.handleFilesOut();
      }
    });

    _defineProperty(this, "handleSelectImageFromAssetSource", source => {
      this.setState({
        selectedAssetSource: source
      });
    });

    _defineProperty(this, "handleAssetSourceClosed", () => {
      this.setState({
        selectedAssetSource: null
      });
    });

    _defineProperty(this, "renderPreview", () => {
      var _this$props6 = this.props,
          value = _this$props6.value,
          readOnly = _this$props6.readOnly,
          type = _this$props6.type,
          directUploads = _this$props6.directUploads,
          imageUrlBuilder = _this$props6.imageUrlBuilder;

      if (!value) {
        return null;
      }

      var hoveringFiles = this.state.hoveringFiles;
      var acceptedFiles = hoveringFiles.filter(file => (0, _resolveUploader.default)(type, file));
      var rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
      return /*#__PURE__*/_react.default.createElement(_ImagePreview.ImagePreview, {
        drag: !(value !== null && value !== void 0 && value._upload) && hoveringFiles.length > 0,
        isRejected: rejectedFilesCount > 0 || !directUploads,
        readOnly: readOnly,
        src: imageUrlBuilder.width(2000).fit('max').image(value).dpr(getDevicePixelRatio()).auto('format').url(),
        alt: "Preview of uploaded image"
      });
    });

    _defineProperty(this, "setToast", toast => {
      this.toast = toast;
    });
  }

  focus() {
    if (this._assetElementRef) {
      this._assetElementRef.focus();
    }
  }

  isImageToolEnabled() {
    return (0, _get2.default)(this.props.type, 'options.hotspot') === true;
  }

  clearUploadStatus() {
    var _this$props$value;

    if ((_this$props$value = this.props.value) !== null && _this$props$value !== void 0 && _this$props$value._upload) {
      this.props.onChange(_PatchEvent.default.from([(0, _PatchEvent.unset)(['_upload'])]));
    }
  }

  cancelUpload() {
    if (this.uploadSubscription) {
      this.uploadSubscription.unsubscribe();
      this.clearUploadStatus();
    }
  }

  uploadFirstAccepted(files) {
    var type = this.props.type;
    var match = files.map(file => ({
      file,
      uploader: (0, _resolveUploader.default)(type, file)
    })).find(result => result.uploader);

    if (match) {
      this.uploadWith(match.uploader, match.file);
    }

    this.setState({
      isMenuOpen: false
    });
  }

  hasFileTargetFocus() {
    var _this$props$focusPath;

    return ((_this$props$focusPath = this.props.focusPath) === null || _this$props$focusPath === void 0 ? void 0 : _this$props$focusPath[0]) === 'asset';
  }

  renderDialogFields(fields) {
    var _this$props7 = this.props,
        value = _this$props7.value,
        compareValue = _this$props7.compareValue,
        focusPath = _this$props7.focusPath,
        onFocus = _this$props7.onFocus,
        level = _this$props7.level,
        type = _this$props7.type,
        onChange = _this$props7.onChange,
        readOnly = _this$props7.readOnly,
        presence = _this$props7.presence,
        imageUrlBuilder = _this$props7.imageUrlBuilder;
    var withImageTool = this.isImageToolEnabled() && value && value.asset;
    var imageToolPresence = withImageTool ? presence.filter(item => item.path[0] === 'hotspot') : _empty.EMPTY_ARRAY;
    return /*#__PURE__*/_react.default.createElement(_ui.Dialog, {
      header: "Edit details",
      id: "".concat(this._inputId, "_dialog"),
      onClose: this.handleCloseDialog,
      width: 1,
      __unstable_autoFocus: false
    }, /*#__PURE__*/_react.default.createElement(_presence.PresenceOverlay, null, /*#__PURE__*/_react.default.createElement(_ui.Box, {
      padding: 4
    }, /*#__PURE__*/_react.default.createElement(_ui.Stack, {
      space: 5
    }, withImageTool && (value === null || value === void 0 ? void 0 : value.asset) && /*#__PURE__*/_react.default.createElement(_ImageToolInput.ImageToolInput, {
      type: type,
      level: level,
      readOnly: Boolean(readOnly),
      imageUrl: imageUrlBuilder.image(value.asset).url(),
      value: value,
      focusPath: focusPath,
      presence: imageToolPresence,
      onFocus: onFocus,
      compareValue: compareValue,
      onChange: onChange
    }), this.renderFields(fields)))));
  }

  renderFields(fields) {
    return fields.map(field => this.renderField(field));
  }

  renderField(field) {
    var _this$props8 = this.props,
        value = _this$props8.value,
        level = _this$props8.level,
        focusPath = _this$props8.focusPath,
        onFocus = _this$props8.onFocus,
        readOnly = _this$props8.readOnly,
        onBlur = _this$props8.onBlur,
        compareValue = _this$props8.compareValue,
        presence = _this$props8.presence,
        markers = _this$props8.markers;
    var fieldValue = value === null || value === void 0 ? void 0 : value[field.name];
    var fieldMarkers = markers.filter(marker => marker.path[0] === field.name);
    return /*#__PURE__*/_react.default.createElement(_ImageInputField.ImageInputField, {
      key: field.name,
      field: field,
      parentValue: value,
      value: fieldValue,
      onChange: this.handleFieldChange,
      onFocus: onFocus,
      compareValue: compareValue,
      onBlur: onBlur,
      readOnly: Boolean(readOnly || field.type.readOnly),
      focusPath: focusPath,
      level: level,
      presence: presence,
      markers: fieldMarkers
    });
  }

  renderAssetMenu() {
    var _this$props9 = this.props,
        value = _this$props9.value,
        readOnly = _this$props9.readOnly,
        assetSources = _this$props9.assetSources,
        type = _this$props9.type,
        directUploads = _this$props9.directUploads,
        imageUrlBuilder = _this$props9.imageUrlBuilder,
        observeAsset = _this$props9.observeAsset;
    var isMenuOpen = this.state.isMenuOpen;
    var asset = value === null || value === void 0 ? void 0 : value.asset;

    if (!asset) {
      return null;
    }

    var accept = (0, _get2.default)(type, 'options.accept', 'image/*');
    var fieldGroups = this.getGroupedFields(type);
    var showAdvancedEditButton = value && (fieldGroups.dialog.length > 0 || asset && this.isImageToolEnabled());
    var browseMenuItem = assetSources && (assetSources === null || assetSources === void 0 ? void 0 : assetSources.length) === 0 ? null : /*#__PURE__*/_react.default.createElement(_ui.MenuItem, {
      icon: _icons.SearchIcon,
      text: "Select",
      onClick: () => {
        this.setState({
          isMenuOpen: false
        });
        this.handleSelectImageFromAssetSource(assetSources[0]);
      },
      disabled: readOnly,
      "data-testid": "file-input-browse-button"
    });

    if (assetSources && assetSources.length > 1) {
      browseMenuItem = assetSources.map(assetSource => {
        return /*#__PURE__*/_react.default.createElement(_ui.MenuItem, {
          key: assetSource.name,
          text: assetSource.title,
          onClick: () => {
            this.setState({
              isMenuOpen: false
            });
            this.handleSelectImageFromAssetSource(assetSource);
          },
          icon: assetSource.icon || _icons.ImageIcon,
          "data-testid": "file-input-browse-button-".concat(assetSource.name),
          disabled: readOnly
        });
      });
    }

    return /*#__PURE__*/_react.default.createElement(_WithReferencedAsset.WithReferencedAsset, {
      observeAsset: observeAsset,
      reference: asset
    }, assetDocument => /*#__PURE__*/_react.default.createElement(_ImageActionsMenu.ImageActionsMenu, {
      isMenuOpen: isMenuOpen,
      onEdit: this.handleOpenDialog,
      showEdit: showAdvancedEditButton,
      onMenuOpen: isOpen => this.setState({
        isMenuOpen: isOpen
      })
    }, /*#__PURE__*/_react.default.createElement(_ActionsMenu.ActionsMenu, {
      onUpload: this.handleSelectFiles,
      browse: browseMenuItem,
      onReset: this.handleRemoveButtonClick,
      downloadUrl: imageUrlBuilder.image(value.asset).forceDownload(assetDocument.originalFilename || "download.".concat(assetDocument.extension)).url(),
      copyUrl: imageUrlBuilder.image(value.asset).url(),
      readOnly: readOnly,
      directUploads: directUploads,
      accept: accept
    })));
  }

  renderBrowser() {
    var _this$props10 = this.props,
        assetSources = _this$props10.assetSources,
        readOnly = _this$props10.readOnly,
        directUploads = _this$props10.directUploads;
    if (assetSources.length === 0) return null;

    if (assetSources.length > 1 && !readOnly && directUploads) {
      return /*#__PURE__*/_react.default.createElement(_ui.MenuButton, {
        id: "".concat(this._inputId, "_assetImageButton"),
        button: /*#__PURE__*/_react.default.createElement(_ui.Button, {
          mode: "ghost",
          text: "Select",
          "data-testid": "file-input-multi-browse-button",
          icon: _icons.SearchIcon,
          iconRight: _icons.ChevronDownIcon
        }),
        menu: /*#__PURE__*/_react.default.createElement(_ui.Menu, null, assetSources.map(assetSource => {
          return /*#__PURE__*/_react.default.createElement(_ui.MenuItem, {
            key: assetSource.name,
            text: assetSource.title,
            onClick: () => {
              this.setState({
                isMenuOpen: false
              });
              this.handleSelectImageFromAssetSource(assetSource);
            },
            icon: assetSource.icon || _icons.ImageIcon,
            disabled: readOnly,
            "data-testid": "file-input-browse-button-".concat(assetSource.name)
          });
        }))
      });
    }

    return /*#__PURE__*/_react.default.createElement(_ui.Button, {
      fontSize: 2,
      text: "Select",
      icon: _icons.SearchIcon,
      mode: "ghost",
      onClick: () => {
        this.setState({
          isMenuOpen: false
        });
        this.handleSelectImageFromAssetSource(assetSources[0]);
      },
      "data-testid": "file-input-browse-button",
      disabled: readOnly
    });
  }

  renderUploadPlaceholder() {
    var _this$props11 = this.props,
        readOnly = _this$props11.readOnly,
        type = _this$props11.type,
        directUploads = _this$props11.directUploads;
    var hoveringFiles = this.state.hoveringFiles;
    var acceptedFiles = hoveringFiles.filter(file => (0, _resolveUploader.default)(type, file));
    var rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    var accept = (0, _get2.default)(type, 'options.accept', 'image/*');
    return /*#__PURE__*/_react.default.createElement("div", {
      style: {
        padding: 1
      }
    }, /*#__PURE__*/_react.default.createElement(_ui.Card, {
      tone: readOnly ? 'transparent' : 'inherit',
      border: true,
      padding: 3,
      style: hoveringFiles.length === 0 ? {
        borderStyle: 'dashed'
      } : {
        borderStyle: 'dashed',
        borderColor: 'transparent'
      }
    }, /*#__PURE__*/_react.default.createElement(_UploadPlaceholder.default, {
      browse: this.renderBrowser(),
      onUpload: this.handleSelectFiles,
      readOnly: readOnly,
      hoveringFiles: hoveringFiles,
      acceptedFiles: acceptedFiles,
      rejectedFilesCount: rejectedFilesCount,
      type: "image",
      accept: accept,
      directUploads: directUploads
    })));
  }

  renderUploadState(uploadState) {
    var _this$_assetElementRe;

    var isUploading = this.state.isUploading;
    var elementHeight = (_this$_assetElementRe = this._assetElementRef) === null || _this$_assetElementRe === void 0 ? void 0 : _this$_assetElementRe.offsetHeight;
    var height = elementHeight === 0 ? undefined : elementHeight;
    return /*#__PURE__*/_react.default.createElement(_UploadProgress.UploadProgress, {
      uploadState: uploadState,
      onCancel: isUploading ? this.handleCancelUpload : undefined,
      onStale: this.handleStaleUpload,
      height: height
    });
  }

  renderAssetSource() {
    var selectedAssetSource = this.state.selectedAssetSource;
    var _this$props12 = this.props,
        value = _this$props12.value,
        observeAsset = _this$props12.observeAsset;

    if (!selectedAssetSource) {
      return null;
    }

    var Component = selectedAssetSource.component;

    if (value && value.asset) {
      return /*#__PURE__*/_react.default.createElement(_WithReferencedAsset.WithReferencedAsset, {
        observeAsset: observeAsset,
        reference: value.asset
      }, imageAsset => /*#__PURE__*/_react.default.createElement(Component, {
        selectedAssets: [imageAsset],
        assetType: "image",
        selectionType: "single",
        onClose: this.handleAssetSourceClosed,
        onSelect: this.handleSelectAssetFromSource
      }));
    }

    return /*#__PURE__*/_react.default.createElement(Component, {
      selectedAssets: [],
      selectionType: "single",
      assetType: "image",
      onClose: this.handleAssetSourceClosed,
      onSelect: this.handleSelectAssetFromSource
    });
  }

  getGroupedFields(type) {
    if (!this._fieldGroupsMemo) {
      var fieldGroups = (0, _groupBy2.default)(type.fields, field => {
        var _field$type, _field$type$options;

        if (field.name === 'asset') {
          return 'asset';
        }

        if (field.name === 'hotspot' || field.name === 'crop') {
          return 'imagetool';
        }

        return (_field$type = field.type) !== null && _field$type !== void 0 && (_field$type$options = _field$type.options) !== null && _field$type$options !== void 0 && _field$type$options.isHighlighted ? 'highlighted' : 'dialog';
      });
      this._fieldGroupsMemo = _objectSpread(_objectSpread(_objectSpread({}, EMPTY_FIELD_GROUPS), fieldGroups), {}, {
        imageToolAndDialog: [...(fieldGroups.imagetool || []), ...(fieldGroups.dialog || [])]
      });
    }

    return this._fieldGroupsMemo;
  }

  componentDidUpdate(prevProps) {
    var _prevProps$focusPath = prevProps.focusPath,
        prevFocusPath = _prevProps$focusPath === void 0 ? [] : _prevProps$focusPath;
    var _this$props$focusPath2 = this.props.focusPath,
        currentFocusPath = _this$props$focusPath2 === void 0 ? [] : _this$props$focusPath2;

    if (prevFocusPath[0] !== 'asset' && currentFocusPath[0] === 'asset') {
      var _this$_assetElementRe2;

      (_this$_assetElementRe2 = this._assetElementRef) === null || _this$_assetElementRe2 === void 0 ? void 0 : _this$_assetElementRe2.focus();
    }
  }

  componentWillUnmount() {
    var getValuePath = this.props.getValuePath;
    var pathId = getValuePath();
    window.localStorage.removeItem("imageHeight_".concat(pathId));
  }

  hasChangeInFields(fields) {
    var _this$props13 = this.props,
        value = _this$props13.value,
        compareValue = _this$props13.compareValue;
    return fields.some(field => !(0, _reactFastCompare.default)(value === null || value === void 0 ? void 0 : value[field.name], compareValue === null || compareValue === void 0 ? void 0 : compareValue[field.name]));
  }

  render() {
    var _value$asset, _compareValue$asset;

    var _this$props14 = this.props,
        type = _this$props14.type,
        value = _this$props14.value,
        compareValue = _this$props14.compareValue,
        level = _this$props14.level,
        markers = _this$props14.markers,
        readOnly = _this$props14.readOnly,
        presence = _this$props14.presence,
        _this$props14$focusPa = _this$props14.focusPath,
        focusPath = _this$props14$focusPa === void 0 ? _empty.EMPTY_ARRAY : _this$props14$focusPa,
        directUploads = _this$props14.directUploads;
    var _this$state = this.state,
        hoveringFiles = _this$state.hoveringFiles,
        selectedAssetSource = _this$state.selectedAssetSource,
        isStale = _this$state.isStale;
    var fieldGroups = this.getGroupedFields(type); // Get presence items for people who are either at the asset field, or at fields shown behind the dialog

    var fieldPresence = presence.filter(item => item.path[0] === 'asset' || fieldGroups.imageToolAndDialog.some(field => item.path[0] === field.name));
    var isDialogOpen = focusPath.length > 0 && fieldGroups.dialog.concat(fieldGroups.imagetool).some(field => focusPath[0] === field.name);

    function getFileTone() {
      var acceptedFiles = hoveringFiles.filter(file => (0, _resolveUploader.default)(type, file));
      var rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;

      if (hoveringFiles.length > 0) {
        if (rejectedFilesCount > 0 || !directUploads) {
          return 'critical';
        }
      }

      if (!(value !== null && value !== void 0 && value._upload) && !readOnly && hoveringFiles.length > 0) {
        return 'primary';
      }

      if (readOnly) {
        return 'transparent';
      }

      return value !== null && value !== void 0 && value._upload && value !== null && value !== void 0 && value.asset ? 'transparent' : 'default';
    }

    var hasValueOrUpload = Boolean((value === null || value === void 0 ? void 0 : value._upload) || (value === null || value === void 0 ? void 0 : value.asset));
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_components.ImperativeToast, {
      ref: this.setToast
    }), /*#__PURE__*/_react.default.createElement(_components.FormFieldSet, {
      __unstable_markers: markers,
      __unstable_presence: isDialogOpen ? _empty.EMPTY_ARRAY : fieldPresence,
      title: type.title,
      description: type.description,
      level: fieldGroups.highlighted.length > 0 ? level : 0,
      __unstable_changeIndicator: false
    }, /*#__PURE__*/_react.default.createElement("div", null, isStale && /*#__PURE__*/_react.default.createElement(_ui.Box, {
      marginBottom: 2
    }, /*#__PURE__*/_react.default.createElement(_UploadWarning.UploadWarning, {
      onClearStale: this.handleClearUploadState
    })), /*#__PURE__*/_react.default.createElement(_changeIndicators.ChangeIndicatorForFieldPath, {
      path: ASSET_FIELD_PATH,
      hasFocus: this.hasFileTargetFocus(),
      isChanged: (value === null || value === void 0 ? void 0 : (_value$asset = value.asset) === null || _value$asset === void 0 ? void 0 : _value$asset._ref) !== (compareValue === null || compareValue === void 0 ? void 0 : (_compareValue$asset = compareValue.asset) === null || _compareValue$asset === void 0 ? void 0 : _compareValue$asset._ref) || this.hasChangeInFields(fieldGroups.imageToolAndDialog)
    }, !(value !== null && value !== void 0 && value._upload) && /*#__PURE__*/_react.default.createElement(_styles.FileTarget, {
      tabIndex: 0,
      disabled: Boolean(readOnly),
      ref: this.setFocusElement,
      onFiles: this.handleSelectFiles,
      onFilesOver: this.handleFilesOver,
      onFilesOut: this.handleFilesOut,
      onFocus: this.handleFileTargetFocus,
      onBlur: this.handleFileTargetBlur,
      tone: getFileTone(),
      $border: hasValueOrUpload || hoveringFiles.length > 0,
      style: {
        padding: 1
      },
      sizing: "border",
      radius: 2
    }, !(value !== null && value !== void 0 && value.asset) && this.renderUploadPlaceholder(), !(value !== null && value !== void 0 && value._upload) && (value === null || value === void 0 ? void 0 : value.asset) && /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, this.renderAssetMenu(), this.renderPreview())), (value === null || value === void 0 ? void 0 : value._upload) && this.renderUploadState(value._upload))), this.renderFields(fieldGroups.highlighted), isDialogOpen && this.renderDialogFields(fieldGroups.dialog), selectedAssetSource && this.renderAssetSource()));
  }

}

exports.default = ImageInput;