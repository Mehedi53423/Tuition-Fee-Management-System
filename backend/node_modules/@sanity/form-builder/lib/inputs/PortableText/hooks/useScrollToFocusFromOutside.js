"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useScrollToFocusFromOutside = useScrollToFocusFromOutside;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _portableTextEditor = require("@sanity/portable-text-editor");

var _react = require("react");

var _scrollIntoViewIfNeeded = _interopRequireDefault(require("scroll-into-view-if-needed"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// This hook will scroll related editor item into view when the focusPath is pointing to a embedded object.
function useScrollToFocusFromOutside(hasFocus, focusPath, objectEditData, scrollElement) {
  var objectEditorPathRef = (0, _react.useRef)(null);
  var focusPathRef = (0, _react.useRef)(null);
  var editor = (0, _portableTextEditor.usePortableTextEditor)(); // This will scroll to the relevant block with focusPath pointing to an embedded object inside.

  (0, _react.useEffect)(() => {
    if (!hasFocus && objectEditData && objectEditData.editorHTMLElementRef.current && objectEditorPathRef.current !== objectEditData.editorPath) {
      (0, _scrollIntoViewIfNeeded.default)(objectEditData.editorHTMLElementRef.current, {
        boundary: scrollElement,
        scrollMode: 'if-needed'
      });
      var point = {
        path: focusPath,
        offset: 0
      };
      var selection = {
        anchor: point,
        focus: point
      };

      if (!_portableTextEditor.PortableTextEditor.isObjectPath(editor, focusPath)) {
        _portableTextEditor.PortableTextEditor.select(editor, selection);
      }

      objectEditorPathRef.current = objectEditData.editorPath;
    }
  }, [editor, focusPath, hasFocus, objectEditData, scrollElement]); // This will scroll to the relevant text block if the focus path directly on a regular text block.

  (0, _react.useEffect)(() => {
    var _PortableTextEditor$g;

    if (!hasFocus && objectEditData === null && focusPath.length === 1 && // Only if single block
    !(0, _isEqual2.default)(focusPath, (_PortableTextEditor$g = _portableTextEditor.PortableTextEditor.getSelection(editor)) === null || _PortableTextEditor$g === void 0 ? void 0 : _PortableTextEditor$g.focus.path) && !_portableTextEditor.PortableTextEditor.isObjectPath(editor, focusPath)) {
      var _PortableTextEditor$f = _portableTextEditor.PortableTextEditor.findByPath(editor, focusPath),
          _PortableTextEditor$f2 = _slicedToArray(_PortableTextEditor$f, 1),
          block = _PortableTextEditor$f2[0];

      var blockElm = _portableTextEditor.PortableTextEditor.findDOMNode(editor, block);

      if (blockElm) {
        (0, _scrollIntoViewIfNeeded.default)(blockElm, {
          boundary: scrollElement,
          scrollMode: 'if-needed'
        });
        var point = {
          path: focusPath,
          offset: 0
        };
        var selection = {
          anchor: point,
          focus: point
        };

        _portableTextEditor.PortableTextEditor.select(editor, selection);

        _portableTextEditor.PortableTextEditor.focus(editor);
      }
    }

    focusPathRef.current = focusPath;
  }, [editor, focusPath, hasFocus, objectEditData, scrollElement]);
}