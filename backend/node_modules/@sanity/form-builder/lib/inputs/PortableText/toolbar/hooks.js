"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useActionGroups = useActionGroups;
exports.useActiveActionKeys = useActiveActionKeys;
exports.useActiveStyleKeys = useActiveStyleKeys;
exports.useFeatures = useFeatures;
exports.useFocusBlock = useFocusBlock;
exports.useFocusChild = useFocusChild;

var _portableTextEditor = require("@sanity/portable-text-editor");

var _paths = require("@sanity/util/paths");

var _react = require("react");

var _useUnique = require("../utils/useUnique");

var _helpers = require("./helpers");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function useFocusBlock() {
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var selection = (0, _portableTextEditor.usePortableTextEditorSelection)(); // eslint-disable-next-line react-hooks/exhaustive-deps

  return (0, _react.useMemo)(() => _portableTextEditor.PortableTextEditor.focusBlock(editor), [editor, selection]); // selection must be an additional dep here
}

function useFocusChild() {
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var selection = (0, _portableTextEditor.usePortableTextEditorSelection)(); // eslint-disable-next-line react-hooks/exhaustive-deps

  return (0, _react.useMemo)(() => _portableTextEditor.PortableTextEditor.focusChild(editor), [editor, selection]); // selection must be an additional dep here
}

function useFeatures() {
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  return (0, _react.useMemo)(() => _portableTextEditor.PortableTextEditor.getPortableTextFeatures(editor), [editor]);
}

function useActionGroups(_ref) {
  var hotkeys = _ref.hotkeys,
      onFocus = _ref.onFocus,
      resolveInitialValue = _ref.resolveInitialValue,
      disabled = _ref.disabled;
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var handleInsertAnnotation = (0, _react.useCallback)( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (type) {
      var initialValue = yield resolveInitialValue(type);

      var paths = _portableTextEditor.PortableTextEditor.addAnnotation(editor, type, initialValue);

      if (paths && paths.markDefPath) {
        _portableTextEditor.PortableTextEditor.blur(editor);

        onFocus(paths.markDefPath.concat(_paths.FOCUS_TERMINATOR));
      }
    });

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }(), [editor, onFocus, resolveInitialValue]);
  return (0, _react.useMemo)(() => editor ? (0, _helpers.getPTEToolbarActionGroups)(editor, disabled, handleInsertAnnotation, hotkeys) : [], [disabled, editor, handleInsertAnnotation, hotkeys]);
}

function useActiveActionKeys(_ref3) {
  var actions = _ref3.actions;
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var selection = (0, _portableTextEditor.usePortableTextEditorSelection)();
  return (0, _useUnique.useUnique)((0, _react.useMemo)(() => {
    var activeAnnotationKeys = _portableTextEditor.PortableTextEditor.activeAnnotations(editor).map(a => a._type);

    return actions.filter(a => {
      if (a.type === 'annotation') {
        return activeAnnotationKeys.includes(a.key);
      }

      if (a.type === 'listStyle') {
        return _portableTextEditor.PortableTextEditor.hasListStyle(editor, a.key);
      }

      return _portableTextEditor.PortableTextEditor.isMarkActive(editor, a.key);
    }).map(a => a.key);
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [editor, // This is needed so that active actions update as `selection` changes
  selection]));
}

function useActiveStyleKeys(_ref4) {
  var items = _ref4.items;
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var focusBlock = useFocusBlock();
  var selection = (0, _portableTextEditor.usePortableTextEditorSelection)();
  return (0, _useUnique.useUnique)((0, _react.useMemo)(() => items.filter(i => _portableTextEditor.PortableTextEditor.hasBlockStyle(editor, i.style)).map(i => i.style), //  eslint-disable-next-line react-hooks/exhaustive-deps
  [focusBlock, // This is needed so that active styles update as `selection` changes
  selection]));
}