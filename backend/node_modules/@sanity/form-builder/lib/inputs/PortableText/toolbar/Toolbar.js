"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Toolbar = Toolbar;

var _portableTextEditor = require("@sanity/portable-text-editor");

var _react = _interopRequireWildcard(require("react"));

var _paths = require("@sanity/util/paths");

var _initialValueTemplates = require("@sanity/initial-value-templates");

var _ui = require("@sanity/ui");

var _icons = require("@sanity/icons");

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _components = require("@sanity/base/components");

var _ActionMenu = require("./ActionMenu");

var _BlockStyleSelect = require("./BlockStyleSelect");

var _InsertMenu = require("./InsertMenu");

var _helpers = require("./helpers");

var _hooks = require("./hooks");

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var RootFlex = (0, _styledComponents.default)(_ui.Flex)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  width: 100%;\n"])));
var StyleSelectBox = (0, _styledComponents.default)(_ui.Box)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  width: 8em;\n"])));
var StyleSelectFlex = (0, _styledComponents.default)(_ui.Flex)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n  border-right: 1px solid var(--card-border-color);\n"])));
var ActionMenuBox = (0, _styledComponents.default)(_ui.Box)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n  ", "\n"])), _ref => {
  var $withInsertMenu = _ref.$withInsertMenu;
  return $withInsertMenu && (0, _styledComponents.css)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n      max-width: max-content;\n      border-right: 1px solid var(--card-border-color);\n    "])));
});
var FullscreenButtonBox = (0, _styledComponents.default)(_ui.Box)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n  border-left: 1px solid var(--card-border-color);\n"])));
var SLOW_INITIAL_VALUE_LIMIT = 300;
var IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
var InnerToolbar = /*#__PURE__*/(0, _react.memo)(function InnerToolbar(_ref2) {
  var actionGroups = _ref2.actionGroups,
      blockStyles = _ref2.blockStyles,
      disabled = _ref2.disabled,
      insertMenuItems = _ref2.insertMenuItems,
      isFullscreen = _ref2.isFullscreen,
      onToggleFullscreen = _ref2.onToggleFullscreen;
  var actionsLen = actionGroups.reduce((acc, x) => acc + x.actions.length, 0);
  var showActionMenu = actionsLen > 0;
  var showInsertMenu = insertMenuItems.length > 0;

  var _useState = (0, _react.useState)(null),
      _useState2 = _slicedToArray(_useState, 2),
      rootElement = _useState2[0],
      setRootElement = _useState2[1];

  var rootElementRect = (0, _ui.useElementRect)(rootElement);
  var collapsed = rootElementRect ? (rootElementRect === null || rootElementRect === void 0 ? void 0 : rootElementRect.width) < 400 : false;
  (0, _components.useRovingFocus)({
    rootElement: rootElement
  });
  return /*#__PURE__*/_react.default.createElement(RootFlex, {
    align: "center",
    ref: setRootElement
  }, /*#__PURE__*/_react.default.createElement(StyleSelectFlex, {
    flex: collapsed ? 1 : undefined
  }, /*#__PURE__*/_react.default.createElement(StyleSelectBox, {
    padding: isFullscreen ? 2 : 1
  }, /*#__PURE__*/_react.default.createElement(_BlockStyleSelect.BlockStyleSelect, {
    disabled: disabled,
    items: blockStyles
  }))), /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    flex: 1
  }, showActionMenu && /*#__PURE__*/_react.default.createElement(ActionMenuBox, {
    flex: collapsed ? undefined : 1,
    padding: isFullscreen ? 2 : 1,
    $withInsertMenu: showInsertMenu
  }, /*#__PURE__*/_react.default.createElement(_ActionMenu.ActionMenu, {
    disabled: disabled,
    collapsed: collapsed,
    groups: actionGroups,
    isFullscreen: isFullscreen
  })), showInsertMenu && /*#__PURE__*/_react.default.createElement(_ui.Box, {
    flex: collapsed ? undefined : 1,
    padding: isFullscreen ? 2 : 1
  }, /*#__PURE__*/_react.default.createElement(_InsertMenu.InsertMenu, {
    disabled: disabled,
    collapsed: collapsed,
    items: insertMenuItems,
    isFullscreen: isFullscreen
  }))), /*#__PURE__*/_react.default.createElement(FullscreenButtonBox, {
    padding: isFullscreen ? 2 : 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Tooltip, {
    content: /*#__PURE__*/_react.default.createElement(_ui.Flex, {
      align: "center",
      padding: 1
    }, /*#__PURE__*/_react.default.createElement(_ui.Box, {
      flex: 1,
      paddingX: 1
    }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
      size: 1
    }, "".concat(isFullscreen ? 'Collapse' : 'Expand', " editor"))), /*#__PURE__*/_react.default.createElement(_ui.Box, {
      marginLeft: 1
    }, /*#__PURE__*/_react.default.createElement(_ui.Hotkeys, {
      keys: ["".concat(IS_MAC ? 'Cmd' : 'Ctrl'), 'Enter']
    }))),
    placement: isFullscreen ? 'bottom' : 'top',
    portal: "default"
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    padding: 2,
    icon: isFullscreen ? _icons.CollapseIcon : _icons.ExpandIcon,
    mode: "bleed",
    onClick: onToggleFullscreen
  }))));
});

function Toolbar(props) {
  var hotkeys = props.hotkeys,
      isFullscreen = props.isFullscreen,
      readOnly = props.readOnly,
      onFocus = props.onFocus,
      onToggleFullscreen = props.onToggleFullscreen;
  var features = (0, _hooks.useFeatures)();
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var selection = (0, _portableTextEditor.usePortableTextEditorSelection)();
  var disabled = readOnly || !selection;

  var _useToast = (0, _ui.useToast)(),
      push = _useToast.push;

  var resolveInitialValue = (0, _react.useCallback)(type => {
    var isSlow = false;
    var slowTimer = setTimeout(() => {
      isSlow = true;
      push({
        id: 'resolving-initial-value',
        status: 'info',
        title: 'Resolving initial value…'
      });
    }, SLOW_INITIAL_VALUE_LIMIT);
    return (0, _initialValueTemplates.resolveInitialValueForType)(type).then(value => {
      if (isSlow) {
        // I found no way to close an existing toast, so this will replace the message in the
        // "Resolving initial value…"-toast and then make sure it gets closed.
        push({
          id: 'resolving-initial-value',
          status: 'info',
          duration: 500,
          title: 'Initial value resolved'
        });
      }

      return value;
    }).catch(error => {
      push({
        title: "Could not resolve initial value",
        id: 'resolving-initial-value',
        description: "Unable to resolve initial value for type: ".concat(type.name, ": ").concat(error.message, "."),
        status: 'error'
      });
      return undefined;
    }).finally(() => clearTimeout(slowTimer));
  }, [push]);
  var handleInsertBlock = (0, _react.useCallback)( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(function* (type) {
      var initialValue = yield resolveInitialValue(type);

      var path = _portableTextEditor.PortableTextEditor.insertBlock(editor, type, initialValue);

      _portableTextEditor.PortableTextEditor.blur(editor);

      onFocus(path.concat(_paths.FOCUS_TERMINATOR));
    });

    return function (_x) {
      return _ref3.apply(this, arguments);
    };
  }(), [editor, onFocus, resolveInitialValue]);
  var handleInsertInline = (0, _react.useCallback)( /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(function* (type) {
      var initialValue = yield resolveInitialValue(type);

      var path = _portableTextEditor.PortableTextEditor.insertChild(editor, type, initialValue);

      _portableTextEditor.PortableTextEditor.blur(editor);

      onFocus(path.concat(_paths.FOCUS_TERMINATOR));
    });

    return function (_x2) {
      return _ref4.apply(this, arguments);
    };
  }(), [editor, onFocus, resolveInitialValue]);
  var actionGroups = (0, _hooks.useActionGroups)({
    hotkeys,
    onFocus,
    resolveInitialValue,
    disabled: true
  });
  var blockStyles = (0, _react.useMemo)(() => (0, _helpers.getBlockStyles)(features), [features]);
  var insertMenuItems = (0, _react.useMemo)(() => (0, _helpers.getInsertMenuItems)(features, disabled, handleInsertBlock, handleInsertInline), [disabled, features, handleInsertBlock, handleInsertInline]);
  return /*#__PURE__*/_react.default.createElement(InnerToolbar, {
    actionGroups: actionGroups,
    blockStyles: blockStyles,
    disabled: disabled,
    insertMenuItems: insertMenuItems,
    isFullscreen: isFullscreen,
    onToggleFullscreen: onToggleFullscreen
  });
}